{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { ElementNode, $isRangeSelection, $applyNodeReplacement, $isElementNode, $isTextNode } from 'lexical';\nimport { addClassNamesToElement, removeClassNamesFromElement } from '@lexical/utils';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass MarkNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'mark';\n  }\n  static clone(node) {\n    return new MarkNode(Array.from(node.__ids), node.__key);\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedNode) {\n    const node = $createMarkNode(serializedNode.ids);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ids: this.getIDs(),\n      type: 'mark',\n      version: 1\n    };\n  }\n  constructor(ids, key) {\n    super(key);\n    this.__ids = ids || [];\n  }\n  createDOM(config) {\n    const element = document.createElement('mark');\n    addClassNamesToElement(element, config.theme.mark);\n    if (this.__ids.length > 1) {\n      addClassNamesToElement(element, config.theme.markOverlap);\n    }\n    return element;\n  }\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          addClassNamesToElement(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        removeClassNamesFromElement(element, overlapTheme);\n      }\n    }\n    return false;\n  }\n  hasID(id) {\n    const ids = this.getIDs();\n    for (let i = 0; i < ids.length; i++) {\n      if (id === ids[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  getIDs() {\n    const self = this.getLatest();\n    return $isMarkNode(self) ? self.__ids : [];\n  }\n  addID(id) {\n    const self = this.getWritable();\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n      for (let i = 0; i < ids.length; i++) {\n        // If we already have it, don't add again\n        if (id === ids[i]) {\n          return;\n        }\n      }\n      ids.push(id);\n    }\n  }\n  deleteID(id) {\n    const self = this.getWritable();\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n      for (let i = 0; i < ids.length; i++) {\n        if (id === ids[i]) {\n          ids.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const markNode = $createMarkNode(this.__ids);\n    this.insertAfter(markNode, restoreSelection);\n    return markNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection) || destination === 'html') {\n      return false;\n    }\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n}\nfunction $createMarkNode(ids) {\n  return $applyNodeReplacement(new MarkNode(ids));\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n    target = child;\n  }\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {\n  const nodes = selection.getNodes();\n  const anchorOffset = selection.anchor.offset;\n  const focusOffset = selection.focus.offset;\n  const nodesLength = nodes.length;\n  const startOffset = isBackward ? focusOffset : anchorOffset;\n  const endOffset = isBackward ? anchorOffset : focusOffset;\n  let currentNodeParent;\n  let lastCreatedMarkNode;\n\n  // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ($isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n    const isFirstNode = i === 0;\n    const isLastNode = i === nodesLength - 1;\n    let targetNode = null;\n    if ($isTextNode(node)) {\n      // Case 1: The node is a text node and we can split it\n      const textContentSize = node.getTextContentSize();\n      const startTextOffset = isFirstNode ? startOffset : 0;\n      const endTextOffset = isLastNode ? endOffset : textContentSize;\n      if (startTextOffset === 0 && endTextOffset === 0) {\n        continue;\n      }\n      const splitNodes = node.splitText(startTextOffset, endTextOffset);\n      targetNode = splitNodes.length > 1 && (splitNodes.length === 3 || isFirstNode && !isLastNode || endTextOffset === textContentSize) ? splitNodes[1] : splitNodes[0];\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may utlimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n\n      continue;\n    } else if ($isElementNode(node) && node.isInline()) {\n      // Case 3: inline element nodes can be added in their entirety to the new\n      // mark\n      targetNode = node;\n    }\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n      const parentNode = targetNode.getParent();\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n      currentNodeParent = parentNode;\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        const createMarkNode = createNode || $createMarkNode;\n        lastCreatedMarkNode = createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      }\n\n      // Add the target node to be wrapped in the latest created mark node\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  }\n  // Make selection collapsed at the end\n  if ($isElementNode(lastCreatedMarkNode)) {\n    // eslint-disable-next-line no-unused-expressions\n    isBackward ? lastCreatedMarkNode.selectStart() : lastCreatedMarkNode.selectEnd();\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if ($isTextNode(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n    currentNode = currentNode.getParent();\n  }\n  return null;\n}\nexport { $createMarkNode, $getMarkIDs, $isMarkNode, $unwrapMarkNode, $wrapSelectionInMarkNode, MarkNode };","map":{"version":3,"names":["ElementNode","$isRangeSelection","$applyNodeReplacement","$isElementNode","$isTextNode","addClassNamesToElement","removeClassNamesFromElement","MarkNode","getType","clone","node","Array","from","__ids","__key","importDOM","importJSON","serializedNode","$createMarkNode","ids","setFormat","format","setIndent","indent","setDirection","direction","exportJSON","getIDs","type","version","constructor","key","createDOM","config","element","document","createElement","theme","mark","length","markOverlap","updateDOM","prevNode","prevIDs","nextIDs","prevIDsCount","nextIDsCount","overlapTheme","hasID","id","i","self","getLatest","$isMarkNode","addID","getWritable","push","deleteID","splice","insertNewAfter","selection","restoreSelection","markNode","insertAfter","canInsertTextBefore","canInsertTextAfter","canBeEmpty","isInline","extractWithChild","child","destination","anchor","focus","anchorNode","getNode","focusNode","isBackward","selectionLength","offset","isParentOf","getTextContent","excludeFromCopy","$unwrapMarkNode","children","getChildren","target","insertBefore","remove","$wrapSelectionInMarkNode","createNode","nodes","getNodes","anchorOffset","focusOffset","nodesLength","startOffset","endOffset","currentNodeParent","lastCreatedMarkNode","isFirstNode","isLastNode","targetNode","textContentSize","getTextContentSize","startTextOffset","endTextOffset","splitNodes","splitText","is","parentNode","getParent","undefined","createMarkNode","append","selectStart","selectEnd","$getMarkIDs","currentNode","nextSibling","getNextSibling"],"sources":["C:/Users/BIT1/IdeaProjects/customer-inquiry-system/frontend/node_modules/@lexical/mark/LexicalMark.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { ElementNode, $isRangeSelection, $applyNodeReplacement, $isElementNode, $isTextNode } from 'lexical';\nimport { addClassNamesToElement, removeClassNamesFromElement } from '@lexical/utils';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass MarkNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'mark';\n  }\n  static clone(node) {\n    return new MarkNode(Array.from(node.__ids), node.__key);\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedNode) {\n    const node = $createMarkNode(serializedNode.ids);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ids: this.getIDs(),\n      type: 'mark',\n      version: 1\n    };\n  }\n  constructor(ids, key) {\n    super(key);\n    this.__ids = ids || [];\n  }\n  createDOM(config) {\n    const element = document.createElement('mark');\n    addClassNamesToElement(element, config.theme.mark);\n    if (this.__ids.length > 1) {\n      addClassNamesToElement(element, config.theme.markOverlap);\n    }\n    return element;\n  }\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          addClassNamesToElement(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        removeClassNamesFromElement(element, overlapTheme);\n      }\n    }\n    return false;\n  }\n  hasID(id) {\n    const ids = this.getIDs();\n    for (let i = 0; i < ids.length; i++) {\n      if (id === ids[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  getIDs() {\n    const self = this.getLatest();\n    return $isMarkNode(self) ? self.__ids : [];\n  }\n  addID(id) {\n    const self = this.getWritable();\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n      for (let i = 0; i < ids.length; i++) {\n        // If we already have it, don't add again\n        if (id === ids[i]) {\n          return;\n        }\n      }\n      ids.push(id);\n    }\n  }\n  deleteID(id) {\n    const self = this.getWritable();\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n      for (let i = 0; i < ids.length; i++) {\n        if (id === ids[i]) {\n          ids.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const markNode = $createMarkNode(this.__ids);\n    this.insertAfter(markNode, restoreSelection);\n    return markNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection) || destination === 'html') {\n      return false;\n    }\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n}\nfunction $createMarkNode(ids) {\n  return $applyNodeReplacement(new MarkNode(ids));\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n    target = child;\n  }\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {\n  const nodes = selection.getNodes();\n  const anchorOffset = selection.anchor.offset;\n  const focusOffset = selection.focus.offset;\n  const nodesLength = nodes.length;\n  const startOffset = isBackward ? focusOffset : anchorOffset;\n  const endOffset = isBackward ? anchorOffset : focusOffset;\n  let currentNodeParent;\n  let lastCreatedMarkNode;\n\n  // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ($isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n    const isFirstNode = i === 0;\n    const isLastNode = i === nodesLength - 1;\n    let targetNode = null;\n    if ($isTextNode(node)) {\n      // Case 1: The node is a text node and we can split it\n      const textContentSize = node.getTextContentSize();\n      const startTextOffset = isFirstNode ? startOffset : 0;\n      const endTextOffset = isLastNode ? endOffset : textContentSize;\n      if (startTextOffset === 0 && endTextOffset === 0) {\n        continue;\n      }\n      const splitNodes = node.splitText(startTextOffset, endTextOffset);\n      targetNode = splitNodes.length > 1 && (splitNodes.length === 3 || isFirstNode && !isLastNode || endTextOffset === textContentSize) ? splitNodes[1] : splitNodes[0];\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may utlimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n\n      continue;\n    } else if ($isElementNode(node) && node.isInline()) {\n      // Case 3: inline element nodes can be added in their entirety to the new\n      // mark\n      targetNode = node;\n    }\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n      const parentNode = targetNode.getParent();\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n      currentNodeParent = parentNode;\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        const createMarkNode = createNode || $createMarkNode;\n        lastCreatedMarkNode = createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      }\n\n      // Add the target node to be wrapped in the latest created mark node\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  }\n  // Make selection collapsed at the end\n  if ($isElementNode(lastCreatedMarkNode)) {\n    // eslint-disable-next-line no-unused-expressions\n    isBackward ? lastCreatedMarkNode.selectStart() : lastCreatedMarkNode.selectEnd();\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if ($isTextNode(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n    currentNode = currentNode.getParent();\n  }\n  return null;\n}\n\nexport { $createMarkNode, $getMarkIDs, $isMarkNode, $unwrapMarkNode, $wrapSelectionInMarkNode, MarkNode };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}