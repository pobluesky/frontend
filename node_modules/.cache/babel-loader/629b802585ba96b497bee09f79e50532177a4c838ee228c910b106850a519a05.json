{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $cloneWithProperties, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { isHTMLElement, isBlockDomNode } from '@lexical/utils';\nimport { $getRoot, $isElementNode, $isTextNode, $isRootOrShadowRoot, $isBlockElementNode, ArtificialNode__DO_NOT_USE, $createLineBreakNode, $createParagraphNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificalNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        element.replaceWith(newElement);\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || (currentConversion.priority || 0) < (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (isBlockDomNode(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isBlockElementNode(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && $isBlockElementNode(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificalNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE) {\n      node.insertAfter($createLineBreakNode());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\nexport { $generateHtmlFromNodes, $generateNodesFromDOM };","map":{"version":3,"names":["$cloneWithProperties","$sliceSelectedTextNodeContent","isHTMLElement","isBlockDomNode","$getRoot","$isElementNode","$isTextNode","$isRootOrShadowRoot","$isBlockElementNode","ArtificialNode__DO_NOT_USE","$createLineBreakNode","$createParagraphNode","$generateNodesFromDOM","editor","dom","elements","body","childNodes","lexicalNodes","allArtificialNodes","i","length","element","IGNORE_TAGS","has","nodeName","lexicalNode","$createNodesFromDOM","concat","$unwrapArtificalNodes","$generateHtmlFromNodes","selection","document","window","global","Error","container","createElement","root","topLevelChildren","getChildren","topLevelNode","$appendNodesToHTML","innerHTML","currentNode","parentElement","shouldInclude","isSelected","shouldExclude","excludeFromCopy","target","clone","children","registeredNode","_nodes","get","getType","exportOutput","exportDOM","undefined","after","fragment","createDocumentFragment","childNode","shouldIncludeChild","extractWithChild","append","newElement","call","replaceWith","getConversionFunction","domNode","cachedConversions","_htmlConversions","toLowerCase","currentConversion","cachedConversion","domConversion","priority","conversion","Set","node","hasBlockAncestorLexicalNode","forChildMap","Map","parentLexicalNode","currentLexicalNode","transformFunction","transformOutput","postTransform","transformNodes","Array","isArray","forChildFunction","push","forChild","set","childLexicalNodes","hasBlockAncestorLexicalNodeForChildren","wrapContinuousInlines","artificialNode","nodes","createWrapperFn","textAlign","style","out","continuousInlines","getFormat","setFormat","wrapper","getNextSibling","insertAfter","child","insertBefore","remove"],"sources":["C:/Users/BIT1/IdeaProjects/customer-inquiry-system/frontend/node_modules/@lexical/html/LexicalHtml.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $cloneWithProperties, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { isHTMLElement, isBlockDomNode } from '@lexical/utils';\nimport { $getRoot, $isElementNode, $isTextNode, $isRootOrShadowRoot, $isBlockElementNode, ArtificialNode__DO_NOT_USE, $createLineBreakNode, $createParagraphNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificalNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        element.replaceWith(newElement);\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || (currentConversion.priority || 0) < (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (isBlockDomNode(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isBlockElementNode(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && $isBlockElementNode(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificalNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE) {\n      node.insertAfter($createLineBreakNode());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\n\nexport { $generateHtmlFromNodes, $generateNodesFromDOM };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}