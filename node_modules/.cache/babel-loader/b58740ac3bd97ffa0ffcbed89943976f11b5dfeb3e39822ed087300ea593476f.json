{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { createRectsFromDOMRange, $cloneWithProperties } from '@lexical/selection';\nimport { $getSelection, $isRangeSelection, TextNode, $getRoot, $isElementNode, $isTextNode, $setSelection, $getPreviousSelection, $isRootOrShadowRoot, $splitNode, $createParagraphNode } from 'lexical';\nexport { $splitNode, isBlockDomNode, isHTMLAnchorElement, isHTMLElement, isInlineDomNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the ending node) so long as it exists\n */\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || $getRoot()).getLatest();\n  const end = endingNode || ($isElementNode(start) ? start.getLastDescendant() || start : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if ($isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  let node = startingNode;\n  if ($isElementNode(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (!$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = $cloneWithProperties(node);\n    if ($isTextNode(clone)) {\n      if (!$isTextNode(node)) {\n        throw Error(`Expected node be a TextNode`);\n      }\n      clone.__text = node.__text;\n    }\n    nodeMap.set(key, clone);\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  $setSelection(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = $getSelection() || $getPreviousSelection();\n  if ($isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ($isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ($isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = $splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = $getRoot();\n      root.append(node);\n    }\n    const paragraphNode = $createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  if (IS_FIREFOX) {\n    return 1;\n  }\n  let zoom = 1;\n  while (element) {\n    zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n    element = element.parentElement;\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\nexport { $dfs, $filter, $findMatchingParent, $getNearestBlockElementAncestorOrThrow, $getNearestNodeOfType, $getNextRightPreorderNode, $insertFirst, $insertNodeToNearestRoot, $isEditorIsNestedEditor, $restoreEditorState, $wrapNodeInElement, CAN_USE_BEFORE_INPUT, CAN_USE_DOM, IS_ANDROID, IS_ANDROID_CHROME, IS_APPLE, IS_APPLE_WEBKIT, IS_CHROME, IS_FIREFOX, IS_IOS, IS_SAFARI, addClassNamesToElement, calculateZoomLevel, isMimeType, markSelection, mediaFileReader, mergeRegister, objectKlassEquals, positionNodeOnRange, registerNestedElementResolver, removeClassNamesFromElement };","map":{"version":3,"names":["createRectsFromDOMRange","$cloneWithProperties","$getSelection","$isRangeSelection","TextNode","$getRoot","$isElementNode","$isTextNode","$setSelection","$getPreviousSelection","$isRootOrShadowRoot","$splitNode","$createParagraphNode","isBlockDomNode","isHTMLAnchorElement","isHTMLElement","isInlineDomNode","CAN_USE_DOM$1","window","document","createElement","documentMode","IS_APPLE$1","test","navigator","platform","IS_FIREFOX$1","userAgent","CAN_USE_BEFORE_INPUT$1","InputEvent","IS_SAFARI$1","IS_IOS$1","MSStream","IS_ANDROID$1","IS_CHROME$1","IS_ANDROID_CHROME$1","IS_APPLE_WEBKIT$1","normalizeClassNames","classNames","rval","className","s","matchAll","push","mergeRegister","func","i","length","px","value","mutationObserverConfig","attributes","characterData","childList","subtree","positionNodeOnRange","editor","range","onReposition","rootDOMNode","parentDOMNode","observer","lastNodes","wrapperNode","position","Error","left","rootLeft","top","rootTop","getBoundingClientRect","parentDOMNode_","rects","isConnected","append","hasRepositioned","rect","rectNode","rectNodeStyle","style","width","height","parentNode","pop","stop","disconnect","remove","node","restart","currentRootDOMNode","getRootElement","currentParentDOMNode","parentElement","HTMLElement","MutationObserver","mutations","nextRootDOMNode","nextParentDOMNode","mutation","contains","target","observe","removeRootListener","registerRootListener","markSelection","previousAnchorNode","previousAnchorOffset","previousFocusNode","previousFocusOffset","removeRangeListener","compute","editorState","read","selection","anchor","focus","currentAnchorNode","getNode","currentAnchorNodeKey","getKey","currentAnchorOffset","offset","currentFocusNode","currentFocusNodeKey","currentFocusOffset","currentAnchorNodeDOM","getElementByKey","currentFocusNodeDOM","differentAnchorDOM","updateDOM","_config","differentFocusDOM","anchorHTMLElement","focusHTMLElement","tagName","createRange","firstHTMLElement","firstOffset","lastHTMLElement","lastOffset","isBefore","firstTextNode","firstChild","lastTextNode","setStart","setEnd","domNodes","domNode","domNodeStyle","background","color","zIndex","pointerEvents","marginTop","paddingTop","paddingBottom","undefined","getEditorState","registerUpdateListener","CAN_USE_BEFORE_INPUT","CAN_USE_DOM","IS_ANDROID","IS_ANDROID_CHROME","IS_APPLE","IS_APPLE_WEBKIT","IS_CHROME","IS_FIREFOX","IS_IOS","IS_SAFARI","addClassNamesToElement","element","classesToAdd","classList","add","removeClassNamesFromElement","classesToRemove","isMimeType","file","acceptableMimeTypes","acceptableType","type","startsWith","mediaFileReader","files","filesIterator","Symbol","iterator","Promise","resolve","reject","processed","handleNextFile","done","next","fileReader","FileReader","addEventListener","result","readAsDataURL","$dfs","startingNode","endingNode","nodes","start","getLatest","end","getLastDescendant","depth","$getDepth","is","getChildrenSize","getFirstChild","sibling","getNextSibling","getParent","innerNode","$getNextRightPreorderNode","getLastChild","getPreviousSibling","$getNearestNodeOfType","klass","parent","$getNearestBlockElementAncestorOrThrow","startNode","blockNode","$findMatchingParent","isInline","__key","findFn","curr","registerNestedElementResolver","targetNode","cloneNode","handleOverlap","$isTargetNode","$findMatch","children","getChildren","child","childNode","$elementNodeTransform","match","nextSiblings","getNextSiblings","nextSiblingsLength","insertAfter","newParent","canBeEmpty","registerNodeTransform","$restoreEditorState","FULL_RECONCILE","nodeMap","Map","activeEditorState","_pendingEditorState","key","_nodeMap","clone","__text","set","_dirtyType","_selection","$insertNodeToNearestRoot","focusNode","focusOffset","focusChild","getChildAtIndex","insertBefore","selectNext","splitNode","splitOffset","getParentOrThrow","getIndexWithinParent","splitText","rightTree","selectStart","getNodes","getTopLevelElementOrThrow","root","paragraphNode","select","$wrapNodeInElement","createElementNode","elementNode","replace","objectKlassEquals","object","objectClass","Object","getPrototypeOf","constructor","name","$filter","filterFn","$insertFirst","calculateZoomLevel","zoom","Number","getComputedStyle","getPropertyValue","$isEditorIsNestedEditor","_parentEditor"],"sources":["C:/Users/BIT1/IdeaProjects/customer-inquiry-system/frontend/node_modules/@lexical/utils/LexicalUtils.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { createRectsFromDOMRange, $cloneWithProperties } from '@lexical/selection';\nimport { $getSelection, $isRangeSelection, TextNode, $getRoot, $isElementNode, $isTextNode, $setSelection, $getPreviousSelection, $isRootOrShadowRoot, $splitNode, $createParagraphNode } from 'lexical';\nexport { $splitNode, isBlockDomNode, isHTMLAnchorElement, isHTMLElement, isInlineDomNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the ending node) so long as it exists\n */\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || $getRoot()).getLatest();\n  const end = endingNode || ($isElementNode(start) ? start.getLastDescendant() || start : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if ($isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  let node = startingNode;\n  if ($isElementNode(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (!$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = $cloneWithProperties(node);\n    if ($isTextNode(clone)) {\n      if (!$isTextNode(node)) {\n        throw Error(`Expected node be a TextNode`);\n      }\n      clone.__text = node.__text;\n    }\n    nodeMap.set(key, clone);\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  $setSelection(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = $getSelection() || $getPreviousSelection();\n  if ($isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ($isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ($isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = $splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = $getRoot();\n      root.append(node);\n    }\n    const paragraphNode = $createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  if (IS_FIREFOX) {\n    return 1;\n  }\n  let zoom = 1;\n  while (element) {\n    zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n    element = element.parentElement;\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\nexport { $dfs, $filter, $findMatchingParent, $getNearestBlockElementAncestorOrThrow, $getNearestNodeOfType, $getNextRightPreorderNode, $insertFirst, $insertNodeToNearestRoot, $isEditorIsNestedEditor, $restoreEditorState, $wrapNodeInElement, CAN_USE_BEFORE_INPUT, CAN_USE_DOM, IS_ANDROID, IS_ANDROID_CHROME, IS_APPLE, IS_APPLE_WEBKIT, IS_CHROME, IS_FIREFOX, IS_IOS, IS_SAFARI, addClassNamesToElement, calculateZoomLevel, isMimeType, markSelection, mediaFileReader, mergeRegister, objectKlassEquals, positionNodeOnRange, registerNestedElementResolver, removeClassNamesFromElement };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}