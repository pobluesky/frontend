{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getSelection, $isRangeSelection, $isTextNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\n            editor.update(() => {\n              const selection = $getSelection();\n              if ($isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if ($isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength;\n                    // If the offset is more than the end, make it the end\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if ($isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\n                  // If the offset is more than the end, make it the end\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                }\n\n                // block the chrome extension from handling this event\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\nexport { registerDragonSupport };","map":{"version":3,"names":["$getSelection","$isRangeSelection","$isTextNode","registerDragonSupport","editor","origin","window","location","handler","event","rootElement","getRootElement","document","activeElement","data","parsedData","JSON","parse","e","protocol","type","payload","functionId","args","elementStart","elementLength","text","selStart","selLength","formatCommand","update","selection","anchor","anchorNode","getNode","setSelStart","setSelEnd","setTextNodeRange","insertRawText","anchorNodeTextLength","getTextContentSize","stopImmediatePropagation","addEventListener","removeEventListener"],"sources":["C:/Users/BIT1/IdeaProjects/customer-inquiry-system/frontend/node_modules/@lexical/dragon/LexicalDragon.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getSelection, $isRangeSelection, $isTextNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\n            editor.update(() => {\n              const selection = $getSelection();\n              if ($isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if ($isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength;\n                    // If the offset is more than the end, make it the end\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if ($isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\n                  // If the offset is more than the end, make it the end\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                }\n\n                // block the chrome extension from handling this event\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\nexport { registerDragonSupport };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}