{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $cloneWithProperties, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getRoot, $parseSerializedNode, $isTextNode, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $isElementNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor) {\n  const selection = $getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @returns\n */\nfunction $getLexicalContent(editor) {\n  const selection = $getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = $getSelection();\n        if ($isRangeSelection(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([$createTabNode()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ($isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = getDOMSelection(editor._window);\n  if (!domSelection) {\n    return false;\n  }\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n  if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = $getSelection();\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard };","map":{"version":3,"names":["$generateHtmlFromNodes","$generateNodesFromDOM","$addNodeStyle","$cloneWithProperties","$sliceSelectedTextNodeContent","objectKlassEquals","$getSelection","$isRangeSelection","$createTabNode","SELECTION_INSERT_CLIPBOARD_NODES_COMMAND","$getRoot","$parseSerializedNode","$isTextNode","COPY_COMMAND","COMMAND_PRIORITY_CRITICAL","isSelectionWithinEditor","$isElementNode","CAN_USE_DOM","window","document","createElement","getDOMSelection","targetWindow","getSelection","$getHtmlContent","editor","selection","Error","isCollapsed","getNodes","length","$getLexicalContent","JSON","stringify","$generateJSONFromSelectedNodes","$insertDataTransferForPlainText","dataTransfer","text","getData","insertRawText","$insertDataTransferForRichText","lexicalString","payload","parse","namespace","_config","Array","isArray","nodes","$generateNodesFromSerializedNodes","$insertGeneratedNodes","_unused","htmlString","parser","DOMParser","dom","parseFromString","_unused2","parts","split","pop","i","currentSelection","part","insertParagraph","insertNodes","insertText","dispatchCommand","exportNodeToJSON","node","serializedNode","exportJSON","nodeClass","constructor","type","getType","name","serializedChildren","children","$appendNodesToJSON","currentNode","targetArray","shouldInclude","isSelected","shouldExclude","excludeFromCopy","target","clone","getChildren","__text","childNode","shouldIncludeChild","extractWithChild","push","serializedChildNode","root","topLevelChildren","topLevelNode","serializedNodes","EVENT_LATENCY","clipboardEventTimeout","copyToClipboard","event","Promise","resolve","reject","update","$copyToClipboardEvent","rootElement","getRootElement","windowDocument","_window","domSelection","element","style","cssText","append","createTextNode","range","Range","setStart","setEnd","removeAllRanges","addRange","removeListener","registerCommand","secondEvent","ClipboardEvent","clearTimeout","setTimeout","execCommand","remove","anchorDOM","anchorNode","focusDOM","focusNode","preventDefault","clipboardData","plainString","getTextContent","setData"],"sources":["C:/Users/BIT1/IdeaProjects/customer-inquiry-system/frontend/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $cloneWithProperties, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getRoot, $parseSerializedNode, $isTextNode, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $isElementNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor) {\n  const selection = $getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @returns\n */\nfunction $getLexicalContent(editor) {\n  const selection = $getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = $getSelection();\n        if ($isRangeSelection(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([$createTabNode()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ($isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = getDOMSelection(editor._window);\n  if (!domSelection) {\n    return false;\n  }\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n  if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = $getSelection();\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\n\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}